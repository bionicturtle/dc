# mean(p_sim)
# median(p_sim)
set.seed(20)
n <- 100
rows <- 100
sim <- rnorm(n*rows, 0, 1)
m <- matrix(sim, rows)
es <- numeric(rows)
for (i in rows) {
m_positive <- m[i, ][m[i, ]>0]
es[i] <- mean(m_positive)
es[i]
}
es
# m_pos_only <-
# p_sim <- sim[sim > 0 ]
# mean(p_sim)
# median(p_sim)
m_positive <- m[1, ][m[1, ]>0]
m_positive
es[1] <- mean(m_positive)
es[1]
m_positive <- m[2, ][m[2, ]>0]
es[2] <- mean(m_positive)
es[2]
es
set.seed(20)
n <- 100
rows <- 100
sim <- rnorm(n*rows, 0, 1)
m <- matrix(sim, rows)
es <- numeric(rows)
for (i in rows) {
m_positive <- m[i, ][m[i, ]>0]
es[i] <- mean(m_positive)
es[i]
}
es
# m_pos_only <-
# p_sim <- sim[sim > 0 ]
# mean(p_sim)
# median(p_sim)
set.seed(20)
n <- 100
rows <- 100
sim <- rnorm(n*rows, 0, 1)
m <- matrix(sim, rows)
es <- numeric(rows)
for (i in rows) {
m_positive <- m[i, ][m[i, ]>0]
es[i] <- mean(m_positive)
}
es
# m_pos_only <-
# p_sim <- sim[sim > 0 ]
# mean(p_sim)
# median(p_sim)
es[1]
set.seed(20)
n <- 100
rows <- 100
sim <- rnorm(n*rows, 0, 1)
m <- matrix(sim, rows)
es <- numeric(rows)
for (i in rows) {
m_positive <- m[i, ][m[i, ]>0]
es[i] <- mean(m_positive)
print(es[i])
}
es
# m_pos_only <-
# p_sim <- sim[sim > 0 ]
# mean(p_sim)
# median(p_sim)
runif(100)
?stdev
?sd
sd(runif(100))
var(runif(100))
var(runif(100))
var(runif(100))
a <- runif(100)
b <- runif(100)
a <- runif(100)
b <- runif(100)
var(a+b)
a <- runif(100)
b <- runif(100)
var(a+b)
a <- runif(100)
b <- runif(100)
var(a+b)
a <- runif(100)
b <- runif(100)
var(a+b)
a <- runif(100)
b <- runif(100)
var(a+b)
a <- runif(100)
b <- runif(100)
var(a+b)
a <- runif(100)
b <- runif(100)
var(2*a+3*b)
a <- runif(100)
b <- runif(100)
var(2*a+3*b)
a <- runif(100)
b <- runif(100)
var(2*a+3*b)
a <- runif(100)
b <- runif(100)
var(2*a+3*b)
a <- runif(100)
b <- runif(100)
var(2*a+3*b)
a <- runif(100)
b <- runif(100)
var(2*a+3*b)
a <- runif(100)
b <- runif(100)
var(2*a+3*b)
a <- runif(1000)
b <- runif(1000)
var(2*a+3*b)
a <- runif(1000)
b <- runif(1000)
var(2*a+3*b)
a <- runif(1000)
b <- runif(1000)
var(2*a+3*b)
a <- runif(1000)
b <- runif(1000)
var(2*a+3*b)
a <- runif(1000)
b <- runif(1000)
var(3*a+9*b)
a <- runif(1000)
b <- runif(1000)
var(3*a+9*b)
a <- runif(1000)
b <- runif(1000)
var(3*a+9*b)
a <- runif(1000)
b <- runif(1000)
var(3*a+9*b)
a <- runif(1000)
b <- runif(1000)
var(3*a+9*b)
a <- runif(1000)
b <- runif(1000)
var(3*a+9*b)
a <- runif(1000)
b <- runif(1000)
var(3*a+9*b)
a <- runif(10000)
b <- runif(10000)
var(3*a+9*b)
a <- runif(10000)
b <- runif(10000)
var(3*a+9*b)
a <- runif(10000)
b <- runif(10000)
var(3*a+9*b)
a <- runif(10000)
b <- runif(10000)
var(3*a+9*b)
a <- runif(10000)
b <- runif(10000)
var(3*a+9*b)
a <- runif(10000)
b <- runif(10000)
var(3*a+9*b)
a <- runif(10000)
b <- runif(10000)
var(3*a+3*b)
a <- runif(10000)
b <- runif(10000)
var(3*a+3*b)
a <- runif(10000, 0, 1)
b <- runif(10000, 0, 1)
var(3*a+3*b)
a <- runif(10000, 0, 1)
b <- runif(10000, 2, 5)
var(3*a+5*b)
a <- runif(10000, 0, 1)
b <- runif(10000, 2, 5)
var(3*a+5*b)
a <- runif(10000, 0, 1)
b <- runif(10000, 2, 5)
var(3*a+5*b)
a <- runif(10000, 0, 1)
b <- runif(10000, 2, 5)
var(3*a+5*b)
a <- runif(10000, 0, 1)
b <- runif(10000, 2, 5)
var(3*a+5*b)
a <- runif(10000, 0, 1)
b <- runif(10000, 2, 5)
var(3*a+5*b)
a <- runif(10000, 0, 1)
b <- runif(10000, 2, 5)
var(3*a+5*b)
a <- runif(10000, 0, 1)
b <- runif(10000, 2, 5)
var(3*a+5*b)
a <- runif(10000, 0, 1)
b <- runif(10000, 2, 5)
var(3*a+5*b)
?runif
a <- runif(10000, 0, 3)
b <- runif(10000, 4, 10)
var(2*a+5*b)
a <- runif(10000, 0, 3)
b <- runif(10000, 4, 10)
var(2*a+5*b)
a <- runif(10000, 0, 3)
b <- runif(10000, 4, 10)
var(2*a+5*b)
a <- runif(10000, 0, 3)
b <- runif(10000, 4, 10)
var(2*a+5*b)
a <- runif(10000, 0, 3)
b <- runif(10000, 4, 10)
var(2*a+5*b)
a <- runif(10000, 0, 3)
b <- runif(10000, 4, 10)
var(2*a+5*b)
install.packages("xml2")
# install.packages("xml2")
library(xml2)
?read_xml
?colnames
lst <- list(c("Mon", "Tues"), c("Wed", "Thurs"), "Fri")
lst
names(lst) <- c("x1", "x2", "x3")
lst
x <- matrix(1:6, nrow = 2)
x
lst <- list(
x = c(2.5, 1.2),
y = c(FALSE, TRUE),
z = c("s", "t")
)
lst
lst[[1]]
Sys.getenv("R_LIBS")
R.home()
Sys.getenv("HOME")
,libPaths()
.libPaths()
?.libPaths
R.home()
Sys.getenv("HOME")
getwd()
R.home()
Sys.getenv("HOME")
getwd()
site_path = R.home(component = "home")
fname = file.path(site_path, "etc", "Rprofile.site")
file.exists(fname)
site_path
Sys.getenv("HOME")
Sys.getenv("HOME")
devtools::install_github("csgillespie/efficient", build_vignettes = TRUE)
devtools::install_github("csgillespie/efficient", build_vignettes = TRUE)
install.packages("Rcpp")
install.packages("Rcpp")
devtools::install_github("csgillespie/efficient", build_vignettes = TRUE)
devtools::install_github("csgillespie/efficient")
debug(devtools::install_github("csgillespie/efficient"))
install.packages("Rcpp")
loadedNamespaces()
install.packages("Rcpp")
install.packages("Rcpp")
install.packages("Rcpp")
.libPaths()
install.packages("dplyr")
library(dplyr)
install.packages("dplyr")
library(dplyr)
library(dplyr)
install.packages("Rcpp")
library(httr)
install.packages("Rcpp")
install.packages("Rcpp")
update.packages()
y
install.packages("Rcpp")
devtools::install_github("csgillespie/efficient", build_vignettes = TRUE)
# debug(devtools::install_github("csgillespie/efficient"))
devtools::install_github("csgillespie/efficientR")
devtools::install_github("csgillespie/efficientR")
install.packages("microbenchmark")
install.packages("profvis")
library("microbenchmark")
library("profvis")
library("ggplot2")
setwd("D:/GitHub/dc/writing-functions")
setwd("D:/GitHub/dc/write-func")
y <- 10
f <- function(x) {
x + y
}
f(10)
# returns 20; because y is not passed as an argument to the function, R looks outside of the function environment
y <- 10
f <- function(x) {
y <- 5
x + y
}
f(10)
#returns 15; the value of y is defined inside of the function
f <- function(x) {
y <- 5
x + y
}
f(5)
# what is value of y?
# Answer: object 'y' not found; i.e., does not exist in the global environment
?ifelse
?class
?range
range(1:10)
# Define example vector x
x <- 1:10
# Use the function template to create the rescale01 function
rescale01 <- function(x) {
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2]- rng[1])
}
rescale01(x)
# Define example vector x
x <- 1:10
# Use the function template to create the rescale01 function
rescale01 <- function(x) {
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2]- rng[1])
}
rescale01(x)
rescale(1:20)
rescale01(1:20)
1 - range(1:20, na.rm = TRUE)
1:30 - range(1:20, na.rm = TRUE)
range(1:20)
# Define example vectors x and y
x <- c( 1, 2, NA, 3, NA)
y <- c(NA, 3, NA, 3,  4)
# Turn this snippet into a function: both_na()
both_na <- function(x, y) {
sum(is.na(x) & is.na(y))
}
both_na(x,y)
?runif
runif(1, 0.985, 1.01)
runif(1, 0.985, 1.01)
runif(1, 0.985, 1.01)
runif(100, 0.985, 1.01)
debt <- 5000    # initial debt
i <- 0          # x axis counter
x_axis <- i     # x axis
y_axis <- debt  # y axis
# Initial plot
plot(x_axis, y_axis, xlim = c(0,10), ylim = c(0,5000))
# Graph your debt
while (debt > 0) {
# Updating variables
debt <- debt - 500
i <- i + 1
x_axis <- c(x_axis, i)
y_axis <- c(y_axis, debt)
# Next plot
plot(x_axis, y_axis, xlim = c(0,10), ylim = c(0,5000))
}
my.temp <- 1:10
my.temp
my.temp <- 1:10
for (i in my.temp) {
print(i)
}
setwd("D:/GitHub/dc/import-financial-data")
load("DC.RData")
load("DC.RData")
head(DC)
data(DC)
head(DC)
library(quantmod)
head(DC)
head(DC)
load("DC.RData")
library(quantmod)
# Look at the head of DC
head(DC)
# Extract the close column
dc_close <- Cl(DC)
load("DC.RData")
library(quantmod)
# Look at the head of DC
head(DC)
# Extract the close column
dc_close <- Cl(DC)
load("DC.RData")
library(quantmod)
# Look at the head of DC
head(DC)
# Extract the close column
dc_close <- Cl(DC)
load("DC.RData")
library(quantmod)
# Look at the head of DC
head(DC)
# Extract the close column
dc_close <- Cl(DC)
libray(quantmod)
library(quantmod)
library(quantmod)
load("DC.RData")
library(quantmod)
# Look at the head of DC
head(DC)
# Extract the close column
dc_close <- Cl(DC)
head(DC)
help("OHLC.Transformations")
oil_data <- Quandl(code = c("CME/CLH2016", "CME/BZH2016"), type = "xts")
library(Quandl)
oil_data <- Quandl(code = c("CME/CLH2016", "CME/BZH2016"), type = "xts")
cl_open
library(Quandl)
# Download CME data for CL and BZ as an xts object
oil_data <- Quandl(code = c("CME/CLH2016", "CME/BZH2016"), type = "xts")
# Look at the column names of the oil_data object
colnames(oil_data)
# Extract the Open price for CLH2016
cl_open <- getPrice(oil_data, symbol = "CLH2016", prefer = "Open$")
# Look at January, 2016 using xts' ISO-8601 subsetting
cl_open["2016-01"]
cl_open
head(oil_data)
# CL and BZ Quandl codes
quandl_codes <- c("CME/CLH2016","CME/BZH2016")
# Download quarterly CL and BZ prices
qtr_price <- Quandl(quandl_codes, collapse = "quarterly", type = "xts")
# View the high prices for both series
Hi(qtr_price)
# Download quarterly CL and BZ returns
qtr_return <- Quandl(quandl_codes, collapse = "quarterly", type = "xts", transform = "rdiff")
# View the settle price returns for both series
getPrice(qtr_return, prefer="Settle")
?eapply
?OHLC
?getSymbols
symbols
# Symbols
symbols <- c("AAPL", "MSFT", "IBM")
# Symbols
Symbols
symbols
getSymbols(symbols)
load("ucb_admit.RData")
load("ucb_admit.RData")
library(dplyr)
library(tidyr)
?spread
?count
load("ucb_admit.RData")
library(dplyr)
library(tidyr)
# Count number of male and female applicants admitted
ucb_counts <- ucb_admit %>%
count(Gender, Admit)
# View result
ucb_counts
# Spread the output across columns
ucb_counts %>%
spread(Admit, n)
ucb_counts
ucb_counts <- ucb_admit %>%
count(Gender, Admit)
ucb_counts
ucb_counts %>%
spread(Admit, n)
?Spread
?spread
ucb_admit %>%
# Table of counts of admission status and gender
count(Gender, Admit) %>%
# Spread output across columns based on admission status
spread(Admit, n) %>%
# Create new variable
mutate(Perc_Admit = Admitted / (Admitted + Rejected))
# Table of counts of admission status and gender for each department
admit_by_dept <- ucb_admit %>%
count(Dept, Gender, Admit) %>%
spread(Admit, n)
# View result
admit_by_dept
# Percentage of those admitted to each department
admit_by_dept %>%
mutate(Perc_Admit = Admitted / (Admitted + Rejected))
# Table of counts of admission status and gender for each department
admit_by_dept_not_spread <- ucb_admit %>%
count(Dept, Gender, Admit)
admit_by_dept_not_spread
admit_by_dept <- ucb_admit %>%
count(Dept, Gender, Admit) %>%
spread(Admit, n)
# View result
admit_by_dept
# Percentage of those admitted to each department
admit_by_dept %>%
mutate(Perc_Admit = Admitted / (Admitted + Rejected))
